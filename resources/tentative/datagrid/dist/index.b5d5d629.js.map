{"mappings":"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","sources":["public/sqlite3-worker1-promiser.js"],"sourcesContent":["/*\n  2022-08-24\n\n  The author disclaims copyright to this source code.  In place of a\n  legal notice, here is a blessing:\n\n  *   May you do good and not evil.\n  *   May you find forgiveness for yourself and forgive others.\n  *   May you share freely, never taking more than you give.\n\n  ***********************************************************************\n\n  This file implements a Promise-based proxy for the sqlite3 Worker\n  API #1. It is intended to be included either from the main thread or\n  a Worker, but only if (A) the environment supports nested Workers\n  and (B) it's _not_ a Worker which loads the sqlite3 WASM/JS\n  module. This file's features will load that module and provide a\n  slightly simpler client-side interface than the slightly-lower-level\n  Worker API does.\n\n  This script necessarily exposes one global symbol, but clients may\n  freely `delete` that symbol after calling it.\n*/\n'use strict';\n/**\n   Configures an sqlite3 Worker API #1 Worker such that it can be\n   manipulated via a Promise-based interface and returns a factory\n   function which returns Promises for communicating with the worker.\n   This proxy has an _almost_ identical interface to the normal\n   worker API, with any exceptions documented below.\n\n   It requires a configuration object with the following properties:\n\n   - `worker` (required): a Worker instance which loads\n   `sqlite3-worker1.js` or a functional equivalent. Note that the\n   promiser factory replaces the worker.onmessage property. This\n   config option may alternately be a function, in which case this\n   function re-assigns this property with the result of calling that\n   function, enabling delayed instantiation of a Worker.\n\n   - `onready` (optional, but...): this callback is called with no\n   arguments when the worker fires its initial\n   'sqlite3-api'/'worker1-ready' message, which it does when\n   sqlite3.initWorker1API() completes its initialization. This is\n   the simplest way to tell the worker to kick off work at the\n   earliest opportunity.\n\n   - `onunhandled` (optional): a callback which gets passed the\n   message event object for any worker.onmessage() events which\n   are not handled by this proxy. Ideally that \"should\" never\n   happen, as this proxy aims to handle all known message types.\n\n   - `generateMessageId` (optional): a function which, when passed an\n   about-to-be-posted message object, generates a _unique_ message ID\n   for the message, which this API then assigns as the messageId\n   property of the message. It _must_ generate unique IDs on each call\n   so that dispatching can work. If not defined, a default generator\n   is used (which should be sufficient for most or all cases).\n\n   - `debug` (optional): a console.debug()-style function for logging\n   information about messages.\n\n   This function returns a stateful factory function with the\n   following interfaces:\n\n   - Promise function(messageType, messageArgs)\n   - Promise function({message object})\n\n   The first form expects the \"type\" and \"args\" values for a Worker\n   message. The second expects an object in the form {type:...,\n   args:...}  plus any other properties the client cares to set. This\n   function will always set the `messageId` property on the object,\n   even if it's already set, and will set the `dbId` property to the\n   current database ID if it is _not_ set in the message object.\n\n   The function throws on error.\n\n   The function installs a temporary message listener, posts a\n   message to the configured Worker, and handles the message's\n   response via the temporary message listener. The then() callback\n   of the returned Promise is passed the `message.data` property from\n   the resulting message, i.e. the payload from the worker, stripped\n   of the lower-level event state which the onmessage() handler\n   receives.\n\n   Example usage:\n\n   ```\n   const config = {...};\n   const sq3Promiser = sqlite3Worker1Promiser(config);\n   sq3Promiser('open', {filename:\"/foo.db\"}).then(function(msg){\n     console.log(\"open response\",msg); // => {type:'open', result: {filename:'/foo.db'}, ...}\n   });\n   sq3Promiser({type:'close'}).then((msg)=>{\n     console.log(\"close response\",msg); // => {type:'close', result: {filename:'/foo.db'}, ...}\n   });\n   ```\n\n   Differences from Worker API #1:\n\n   - exec's {callback: STRING} option does not work via this\n   interface (it triggers an exception), but {callback: function}\n   does and works exactly like the STRING form does in the Worker:\n   the callback is called one time for each row of the result set,\n   passed the same worker message format as the worker API emits:\n\n     {type:typeString,\n      row:VALUE,\n      rowNumber:1-based-#,\n      columnNames: array}\n\n   Where `typeString` is an internally-synthesized message type string\n   used temporarily for worker message dispatching. It can be ignored\n   by all client code except that which tests this API. The `row`\n   property contains the row result in the form implied by the\n   `rowMode` option (defaulting to `'array'`). The `rowNumber` is a\n   1-based integer value incremented by 1 on each call into th \n   callback.\n\n   At the end of the result set, the same event is fired with\n   (row=undefined, rowNumber=null) to indicate that\n   the end of the result set has been reached. Note that the rows\n   arrive via worker-posted messages, with all the implications\n   of that.\n*/\nself.sqlite3Worker1Promiser = function callee(config = callee.defaultConfig){\n  // Inspired by: https://stackoverflow.com/a/52439530\n  if(1===arguments.length && 'function'===typeof arguments[0]){\n    const f = config;\n    config = Object.assign(Object.create(null), callee.defaultConfig);\n    config.onready = f;\n  }else{\n    config = Object.assign(Object.create(null), callee.defaultConfig, config);\n  }\n  const handlerMap = Object.create(null);\n  const noop = function(){};\n  const err = config.onerror\n        || noop /* config.onerror is intentionally undocumented\n                   pending finding a less ambiguous name */;\n  const debug = config.debug || noop;\n  const idTypeMap = config.generateMessageId ? undefined : Object.create(null);\n  const genMsgId = config.generateMessageId || function(msg){\n    return msg.type+'#'+(idTypeMap[msg.type] = (idTypeMap[msg.type]||0) + 1);\n  };\n  const toss = (...args)=>{throw new Error(args.join(' '))};\n  if(!config.worker) config.worker = callee.defaultConfig.worker;\n  if('function'===typeof config.worker) config.worker = config.worker();\n  let dbId;\n  config.worker.onmessage = function(ev){\n    ev = ev.data;\n    debug('worker1.onmessage',ev);\n    let msgHandler = handlerMap[ev.messageId];\n    if(!msgHandler){\n      if(ev && 'sqlite3-api'===ev.type && 'worker1-ready'===ev.result) {\n        /*fired one time when the Worker1 API initializes*/\n        if(config.onready) config.onready();\n        return;\n      }\n      msgHandler = handlerMap[ev.type] /* check for exec per-row callback */;\n      if(msgHandler && msgHandler.onrow){\n        msgHandler.onrow(ev);\n        return;\n      }        \n      if(config.onunhandled) config.onunhandled(arguments[0]);\n      else err(\"sqlite3Worker1Promiser() unhandled worker message:\",ev);\n      return;\n    }\n    delete handlerMap[ev.messageId];\n    switch(ev.type){\n        case 'error':\n          msgHandler.reject(ev);\n          return;\n        case 'open':\n          if(!dbId) dbId = ev.dbId;\n          break;\n        case 'close':\n          if(ev.dbId===dbId) dbId = undefined;\n          break;\n        default:\n          break;\n    }\n    try {msgHandler.resolve(ev)}\n    catch(e){msgHandler.reject(e)}\n  }/*worker.onmessage()*/;\n  return function(/*(msgType, msgArgs) || (msgEnvelope)*/){\n    let msg;\n    if(1===arguments.length){\n      msg = arguments[0];\n    }else if(2===arguments.length){\n      msg = {\n        type: arguments[0],\n        args: arguments[1]\n      };\n    }else{\n      toss(\"Invalid arugments for sqlite3Worker1Promiser()-created factory.\");\n    }\n    if(!msg.dbId) msg.dbId = dbId;\n    msg.messageId = genMsgId(msg);\n    msg.departureTime = performance.now();\n    const proxy = Object.create(null);\n    proxy.message = msg;\n    let rowCallbackId /* message handler ID for exec on-row callback proxy */;\n    if('exec'===msg.type && msg.args){\n      if('function'===typeof msg.args.callback){\n        rowCallbackId = msg.messageId+':row';\n        proxy.onrow = msg.args.callback;\n        msg.args.callback = rowCallbackId;\n        handlerMap[rowCallbackId] = proxy;\n      }else if('string' === typeof msg.args.callback){\n        toss(\"exec callback may not be a string when using the Promise interface.\");\n        /**\n           Design note: the reason for this limitation is that this\n           API takes over worker.onmessage() and the client has no way\n           of adding their own message-type handlers to it. Per-row\n           callbacks are implemented as short-lived message.type\n           mappings for worker.onmessage().\n\n           We \"could\" work around this by providing a new\n           config.fallbackMessageHandler (or some such) which contains\n           a map of event type names to callbacks. Seems like overkill\n           for now, seeing as the client can pass callback functions\n           to this interface (whereas the string-form \"callback\" is\n           needed for the over-the-Worker interface).\n        */\n      }\n    }\n    //debug(\"requestWork\", msg);\n    let p = new Promise(function(resolve, reject){\n      proxy.resolve = resolve;\n      proxy.reject = reject;\n      handlerMap[msg.messageId] = proxy;\n      debug(\"Posting\",msg.type,\"message to Worker dbId=\"+(dbId||'default')+':',msg);\n      config.worker.postMessage(msg);\n    });\n    if(rowCallbackId) p = p.finally(()=>delete handlerMap[rowCallbackId]);\n    return p;\n  };\n}/*sqlite3Worker1Promiser()*/;\nself.sqlite3Worker1Promiser.defaultConfig = {\n  worker: function(){\n    let theJs = \"sqlite3-worker1.js\";\n    if(this.currentScript){\n      const src = this.currentScript.src.split('/');\n      src.pop();\n      theJs = src.join('/')+'/' + theJs;\n      //console.warn(\"promiser currentScript, theJs =\",this.currentScript,theJs);\n    }else{\n      //console.warn(\"promiser self.location =\",self.location);\n      const urlParams = new URL(self.location.href).searchParams;\n      if(urlParams.has('sqlite3.dir')){\n        theJs = urlParams.get('sqlite3.dir') + '/' + theJs;\n      }\n    }\n    return new Worker(theJs + self.location.search);\n  }.bind({\n    currentScript: self?.document?.currentScript\n  }),\n  onerror: (...args)=>console.error('worker1 promiser error',...args)\n};\n"],"names":["self","sqlite3Worker1Promiser","callee","config","defaultConfig","arguments","length","f","Object","assign","create","onready","handlerMap","noop","err","onerror","debug","idTypeMap","generateMessageId","undefined","genMsgId","msg","type","toss","args","Error","join","dbId","worker","onmessage","ev","data","msgHandler","messageId","result","onrow","onunhandled","reject","resolve","e","departureTime","performance","now","proxy","rowCallbackId","message","callback","p","Promise","postMessage","finally","theJs","this","currentScript","src","split","pop","urlParams","URL","location","href","searchParams","has","get","Worker","search","bind","document","console","error"],"version":3,"file":"index.b5d5d629.js.map"}